use anyhow::Context;
use std::path::{Path, PathBuf};
use tracing::info;

/// Binary name for the current platform
fn binary_name() -> &'static str {
    if cfg!(windows) {
        "exiv_system.exe"
    } else {
        "exiv_system"
    }
}

/// Generate a cryptographically random API key (64 hex chars)
fn generate_api_key() -> String {
    use rand::rngs::OsRng;
    use rand::Rng;
    let bytes: [u8; 32] = OsRng.gen();
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

/// Generate .env file content
fn env_template(prefix: &Path, api_key: &str) -> String {
    let timestamp = chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ");
    let db_path = prefix.join("data").join("exiv_memories.db");

    format!(
        r#"# ============================================================
# Exiv System Configuration
# Generated by Exiv System install on {timestamp}
# ============================================================

# --- Server ---
PORT=8081
RUST_LOG=info

# --- Security (Principle #5: Strict Permission Isolation) ---
# Admin API key for protected endpoints (plugin config, permissions, shutdown).
# REQUIRED: Without this, all admin operations are denied in release builds.
# Pass via X-API-Key header.
EXIV_API_KEY={api_key}

# --- Database ---
# SQLite database path. The data/ directory is created automatically.
DATABASE_URL=sqlite:{db_path}

# --- AI Provider API Keys ---
# Uncomment and set to enable reasoning engines.
# DEEPSEEK_API_KEY=
# CEREBRAS_API_KEY=

# --- Consensus (Principle #8: Dynamic Intelligence Orchestration) ---
# Comma-separated reasoning engine IDs for consensus: mode.
# Messages prefixed with "consensus:" are routed to all listed engines.
# CONSENSUS_ENGINES=mind.deepseek,mind.cerebras

# --- Agent ---
# DEFAULT_AGENT_ID=agent.exiv_default

# --- Tuning ---
# MAX_EVENT_DEPTH=10
# PLUGIN_EVENT_TIMEOUT_SECS=30
# MEMORY_CONTEXT_LIMIT=10

# --- Remote Update (Principle #8: HITL) ---
# GitHub repository for update distribution (owner/repo).
# Used by GET /api/system/update/check and POST /api/system/update/apply.
# EXIV_UPDATE_REPO=Exiv-ai/Exiv

# --- Network ---
# CORS origins (comma-separated). The embedded dashboard is served from
# the same origin, so CORS is only needed for external API clients.
# CORS_ORIGINS=http://localhost:5173

# --- Plugin Network Access (Principle #5) ---
# Additional hosts that plugins with NetworkAccess permission may reach.
# Default whitelist: api.deepseek.com, api.cerebras.ai, api.openai.com, api.anthropic.com
# ALLOWED_HOSTS=
"#,
        timestamp = timestamp,
        api_key = api_key,
        db_path = db_path.display(),
    )
}

/// Install Exiv to the specified prefix directory
pub async fn install(prefix: PathBuf, service: bool, user: Option<String>) -> anyhow::Result<()> {
    println!("=== Exiv System Installer ===");
    println!("  Prefix:  {}", prefix.display());
    println!("  Service: {}", service);
    println!();

    // 1. Create directories
    let scripts_dir = prefix.join("scripts");
    let data_dir = prefix.join("data");
    std::fs::create_dir_all(&scripts_dir)
        .with_context(|| format!("Failed to create {}", scripts_dir.display()))?;
    std::fs::create_dir_all(&data_dir)
        .with_context(|| format!("Failed to create {}", data_dir.display()))?;
    info!("ðŸ“ Created directories");

    // 2. Copy self (binary) to prefix
    let src_exe = std::env::current_exe().context("Cannot determine current executable path")?;
    let dst_exe = prefix.join(binary_name());
    if src_exe == dst_exe {
        info!("ðŸ“¦ Binary already in place");
    } else {
        std::fs::copy(&src_exe, &dst_exe)
            .with_context(|| format!("Failed to copy binary to {}", dst_exe.display()))?;
        crate::platform::set_executable_permission(&dst_exe)?;
        info!("ðŸ“¦ Installed binary: {}", dst_exe.display());
    }

    // 3. Generate .env (skip if exists)
    let env_path = prefix.join(".env");
    if env_path.exists() {
        info!("â„¹ï¸  .env already exists, skipping");
    } else {
        let api_key = generate_api_key();
        let env_content = env_template(&prefix, &api_key);
        std::fs::write(&env_path, env_content).context("Failed to write .env")?;
        // Restrict .env permissions (contains EXIV_API_KEY)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            std::fs::set_permissions(&env_path, std::fs::Permissions::from_mode(0o600))
                .context("Failed to set .env permissions to 0600")?;
        }
        info!("ðŸ”‘ Generated .env with EXIV_API_KEY");
        println!("  EXIV_API_KEY has been auto-generated. Save it securely:");
        println!("  {}", api_key);
    }

    // 4. Register service (optional)
    if service {
        crate::platform::install_service(&prefix, user.as_deref())?;
    }

    // 5. Summary
    println!();
    println!("=== Installation complete ===");
    println!();
    println!(
        "  To run manually:  cd {} && ./{}",
        prefix.display(),
        binary_name()
    );
    if service {
        if cfg!(windows) {
            println!("  As service:       sc.exe start Exiv");
        } else {
            println!("  As service:       sudo systemctl start exiv");
        }
    }
    println!("  Dashboard:        http://localhost:8081");
    println!();

    Ok(())
}

/// Uninstall Exiv from the specified prefix directory
pub async fn uninstall(prefix: PathBuf) -> anyhow::Result<()> {
    println!("=== Exiv System Uninstaller ===");

    // Stop and remove service
    let _ = crate::platform::uninstall_service();

    if prefix.exists() {
        println!("Removing {}...", prefix.display());
        std::fs::remove_dir_all(&prefix)
            .with_context(|| format!("Failed to remove {}", prefix.display()))?;
    }

    println!("Exiv uninstalled.");
    Ok(())
}
