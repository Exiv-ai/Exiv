use anyhow::Context;
use std::path::{Path, PathBuf};
use tracing::info;

// Embedded Python bridge scripts (extracted during install)
const BRIDGE_RUNTIME_PY: &str = include_str!("../../../scripts/bridge_runtime.py");
const BRIDGE_MAIN_PY: &str = include_str!("../../../scripts/bridge_main.py");
const REQUIREMENTS_TXT: &str = include_str!("../../../scripts/requirements.txt");

/// Binary name for the current platform
fn binary_name() -> &'static str {
    if cfg!(windows) { "exiv_system.exe" } else { "exiv_system" }
}

/// Generate a cryptographically random API key (64 hex chars)
fn generate_api_key() -> String {
    use rand::rngs::OsRng;
    use rand::Rng;
    let bytes: [u8; 32] = OsRng.gen();
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

/// Generate .env file content
fn env_template(prefix: &Path, api_key: &str) -> String {
    let timestamp = chrono::Utc::now().format("%Y-%m-%dT%H:%M:%SZ");
    let db_path = prefix.join("data").join("exiv_memories.db");

    format!(
        r#"# ============================================================
# Exiv System Configuration
# Generated by Exiv System install on {timestamp}
# ============================================================

# --- Server ---
PORT=8081
RUST_LOG=info

# --- Security (Principle #5: Strict Permission Isolation) ---
# Admin API key for protected endpoints (plugin config, permissions, shutdown).
# REQUIRED: Without this, all admin operations are denied in release builds.
# Pass via X-API-Key header.
EXIV_API_KEY={api_key}

# --- Database ---
# SQLite database path. The data/ directory is created automatically.
DATABASE_URL=sqlite:{db_path}

# --- AI Provider API Keys ---
# Uncomment and set to enable reasoning engines.
# DEEPSEEK_API_KEY=
# CEREBRAS_API_KEY=

# --- Consensus (Principle #8: Dynamic Intelligence Orchestration) ---
# Comma-separated reasoning engine IDs for consensus: mode.
# Messages prefixed with "consensus:" are routed to all listed engines.
# CONSENSUS_ENGINES=mind.deepseek,mind.cerebras

# --- Agent ---
# DEFAULT_AGENT_ID=agent.exiv_default

# --- Tuning ---
# MAX_EVENT_DEPTH=10
# PLUGIN_EVENT_TIMEOUT_SECS=30
# MEMORY_CONTEXT_LIMIT=10

# --- Remote Update (Principle #8: HITL) ---
# GitHub repository for update distribution (owner/repo).
# Used by GET /api/system/update/check and POST /api/system/update/apply.
# EXIV_UPDATE_REPO=Exiv-ai/Exiv

# --- Network ---
# CORS origins (comma-separated). The embedded dashboard is served from
# the same origin, so CORS is only needed for external API clients.
# CORS_ORIGINS=http://localhost:5173

# --- Plugin Network Access (Principle #5) ---
# Additional hosts that plugins with NetworkAccess permission may reach.
# Default whitelist: api.deepseek.com, api.cerebras.ai, api.openai.com, api.anthropic.com
# ALLOWED_HOSTS=
"#,
        timestamp = timestamp,
        api_key = api_key,
        db_path = db_path.display(),
    )
}

/// Install Exiv to the specified prefix directory
pub async fn install(
    prefix: PathBuf,
    service: bool,
    no_python: bool,
    user: Option<String>,
) -> anyhow::Result<()> {
    println!("=== Exiv System Installer ===");
    println!("  Prefix:  {}", prefix.display());
    println!("  Service: {}", service);
    println!("  Python:  {}", !no_python);
    println!();

    // 1. Create directories
    let scripts_dir = prefix.join("scripts");
    let data_dir = prefix.join("data");
    std::fs::create_dir_all(&scripts_dir)
        .with_context(|| format!("Failed to create {}", scripts_dir.display()))?;
    std::fs::create_dir_all(&data_dir)
        .with_context(|| format!("Failed to create {}", data_dir.display()))?;
    info!("üìÅ Created directories");

    // 2. Copy self (binary) to prefix
    let src_exe = std::env::current_exe()
        .context("Cannot determine current executable path")?;
    let dst_exe = prefix.join(binary_name());
    if src_exe != dst_exe {
        std::fs::copy(&src_exe, &dst_exe)
            .with_context(|| format!("Failed to copy binary to {}", dst_exe.display()))?;
        crate::platform::set_executable_permission(&dst_exe)?;
        info!("üì¶ Installed binary: {}", dst_exe.display());
    } else {
        info!("üì¶ Binary already in place");
    }

    // 3. Extract embedded Python scripts
    std::fs::write(scripts_dir.join("bridge_runtime.py"), BRIDGE_RUNTIME_PY)
        .context("Failed to write bridge_runtime.py")?;
    std::fs::write(scripts_dir.join("bridge_main.py"), BRIDGE_MAIN_PY)
        .context("Failed to write bridge_main.py")?;
    std::fs::write(scripts_dir.join("requirements.txt"), REQUIREMENTS_TXT)
        .context("Failed to write requirements.txt")?;
    info!("üêç Extracted Python bridge scripts");

    // 4. Generate .env (skip if exists)
    let env_path = prefix.join(".env");
    if !env_path.exists() {
        let api_key = generate_api_key();
        let env_content = env_template(&prefix, &api_key);
        std::fs::write(&env_path, env_content)
            .context("Failed to write .env")?;
        // Restrict .env permissions (contains EXIV_API_KEY)
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            std::fs::set_permissions(&env_path, std::fs::Permissions::from_mode(0o600))
                .context("Failed to set .env permissions to 0600")?;
        }
        info!("üîë Generated .env with EXIV_API_KEY");
        println!("  EXIV_API_KEY has been auto-generated. Save it securely:");
        println!("  {}", api_key);
    } else {
        info!("‚ÑπÔ∏è  .env already exists, skipping");
    }

    // 5. Python venv setup (optional)
    if !no_python {
        setup_python_venv(&prefix)?;
    }

    // 6. Register service (optional)
    if service {
        crate::platform::install_service(&prefix, user.as_deref())?;
    }

    // 7. Summary
    println!();
    println!("=== Installation complete ===");
    println!();
    println!("  To run manually:  cd {} && ./{}", prefix.display(), binary_name());
    if service {
        if cfg!(windows) {
            println!("  As service:       sc.exe start Exiv");
        } else {
            println!("  As service:       sudo systemctl start vers");
        }
    }
    println!("  Dashboard:        http://localhost:8081");
    println!();

    Ok(())
}

/// Uninstall Exiv from the specified prefix directory
pub async fn uninstall(prefix: PathBuf) -> anyhow::Result<()> {
    println!("=== Exiv System Uninstaller ===");

    // Stop and remove service
    let _ = crate::platform::uninstall_service();

    if prefix.exists() {
        println!("Removing {}...", prefix.display());
        std::fs::remove_dir_all(&prefix)
            .with_context(|| format!("Failed to remove {}", prefix.display()))?;
    }

    println!("Exiv uninstalled.");
    Ok(())
}

/// Set up Python virtual environment
fn setup_python_venv(prefix: &Path) -> anyhow::Result<()> {
    let python = if cfg!(windows) { "python" } else { "python3" };

    // Check if python is available
    if std::process::Command::new(python).arg("--version").output().is_err() {
        println!("  ‚ö†Ô∏è  {} not found, skipping venv setup", python);
        return Ok(());
    }

    let venv_dir = prefix.join("venv");
    if !venv_dir.exists() {
        info!("üêç Creating Python venv...");
        let status = std::process::Command::new(python)
            .args(["-m", "venv"])
            .arg(&venv_dir)
            .status()
            .context("Failed to create venv")?;
        if !status.success() {
            anyhow::bail!("python -m venv failed");
        }
    }

    let pip = if cfg!(windows) {
        venv_dir.join("Scripts").join("pip.exe")
    } else {
        venv_dir.join("bin").join("pip")
    };

    let requirements = prefix.join("scripts").join("requirements.txt");

    // Upgrade pip
    let _ = std::process::Command::new(&pip)
        .args(["install", "--quiet", "--upgrade", "pip"])
        .status();

    // Install requirements
    let status = std::process::Command::new(&pip)
        .args(["install", "--quiet", "-r"])
        .arg(&requirements)
        .status()
        .context("Failed to install Python dependencies")?;

    if status.success() {
        info!("üêç Python dependencies installed");
    } else {
        println!("  ‚ö†Ô∏è  pip install returned non-zero, some dependencies may be missing");
    }

    Ok(())
}
